<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Don't Crash! Tailing Behaviour 🦆🦆🦆🦆 | Leen  Alzebdeh</title>
    <meta name="author" content="Leen  Alzebdeh">
    <meta name="description" content="I implement autonomous driving that includes tailing behavious behind other robots (Duckiebots).">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://leenzebdeh.github.io/projects/412_lab4/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header --><header>

  <!-- Nav Bar -->
  <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Leen </span>Alzebdeh</a>
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>

      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">

          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">about</a>
          </li>
          <!-- Other pages -->
          <li class="nav-item ">
            <a class="nav-link" href="/publications/">publications</a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="/projects/">projects</a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="/cv/">cv</a>
          </li>

          <!-- Toogle theme mode -->
          <li class="toggle-container">
            <button id="light-toggle" title="Change theme">
              <i class="fas fa-moon"></i>
              <i class="fas fa-sun"></i>
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  
  <!-- Scrolling Progress Bar -->
  <progress id="progress" value="0">
    <div class="progress-container">
      <span class="progress-bar"></span>
    </div>
  </progress>
</header>

    <!-- Content -->
    <div class="container mt-5">
      <!-- page.html -->
        <div class="post">

          <header class="post-header">
            <h1 class="post-title">Don't Crash! Tailing Behaviour 🦆🦆🦆🦆</h1>
            <p class="post-description">I implement autonomous driving that includes tailing behavious behind other robots (Duckiebots).</p>
          </header>

          <article>
            <p><a href="https://github.com/Leen-Alzebdeh/duckietown/tree/main/lab4" rel="external nofollow noopener" target="_blank">Link to the GitHub repo</a></p>

<p><b> Contributors </b> <br>
Leen Alzebdeh and Tianming Han</p>

<h2 id="summary">Summary</h2>

<p>In this exercise, we managed to write a node that attempts to drive the robot autonomously inside the lane, and safely keep a distance and follow if a Duckiebot is driving or turning ahead of it. We did not meet the goal of driving the robot two laps around the duckietown while maintaining a safe tailing behavior due to inconsistent performance of the program. Despite that, we encountered many programmatic and physical challenges from implementing a safe driving program in a multithreaded environment using software tools such as OpenCV, message bus and services, and we learned about some possible ways to handle such challenges.</p>

<h2 id="objective">Objective</h2>

<p> Our objective is to implement autonomous tailing behavior on our duckiebot, where it can maintain a safe distance with the robot in front of it while driving and turning. We will implement stop line detection and utilize the existing implementation of duckiebot detection node for intersection handling and tailing. </p>

<h2 id="background">Background</h2>

<p> In the last exercise, we implemented autonomous lane following, where the Duckiebot can stay inside the lane while driving straight, and localize its position in the world using AprilTags. In this exercise we need a map in order to know the legal turns at an intersection, therefore we also included our AprilTag detection code from last exercise. </p>

<h2 id="methods-and-results">Methods and Results</h2>

<p>The template code for this exercise contains a Duckiebot detection node that can process the camera input and extract the position of the dot pattern at the back of the leading Duckiebot when we are following it. The detection output gives us the 3D distance and image position of the dot pattern so we know where the robot in front of us is relative to our robot.</p>

<p>Before starting to implement tailing behavior, we modified our lane following code from the last exercise so our robot drives on the right side of the road. This is done by replacing the horizontal image coordinates in the code x by image_width - x, and running the resulting program on the robot shows it is able to follow its own lane but will bump into AprilTag after it enters an intersection.</p>

<h4 id="turning-at-an-intersection">Turning at an Intersection</h4>

<p>To give our robot the ability to make a safe turn at an intersection, we need to let it stop at the stop line and know which direction it should turn. We detect the stop line by applying a red color mask to the camera input and find the largest contour, and compare its y-value with a threshold below which we recognize that the robot is close enough to the stop line and we should stop. <br>

After stopping at the stop line, the robot will start executing a predefined sequence of actions depending on the direction that it wants to turn: If it turns left, it will drive forward into the intersection and make a 90 degree turn to the left in-place; if it turns right, it still drive forward a bit to avoid hitting the AprilTag at its right, and then make a 90 degree turn to the right. After entering the target lane it will resume the lane following code. Note while it starts to turn we also set a timer so it will wait a while before it starts detecting the next stop line at the next intersection. <br>

The robot also needs to know which directions are legal to turn to, so it will not suddenly turn off the road while it is driving autonomously by itself. We tried two approaches to this: using camera input and using AprilTag localization. Since the duckietown has a stop line at each entry of the intersection, we can detect those stop lines to determine which way is legal to turn to. We use the same red color masking as before and extracted a few more contours, and when those contours fall into specific regions on the image, the robot recognizes there is a road in that way which it can make a turn into. However, this approach has two issues, and they led us to discard this solution to use AprilTag detections: <br>

</p>
<ol>
<li>When the robot makes a turn, it can not see the target road at the left side until after it turns left. This makes it difficult to judge if there is a road at the left side. Initially we let the robot rotate a bit to the left to see if there is a road, but then because the motor input is quite imprecise that the duckiebot can not get its orientation back to align with the current lane so it can make a good turn. We then tried to take a shortcut to just detect the roads at the forward and right directions, which appear to work for a single robot case.</li>

<li>Later in the exercise when we tried to let our robot follow the leader robot, it sometimes failed since the leader robot blocked the sight of the camera when it made a turn, and our robot could not see the stop lines at the other intersections. </li>
</ol>

After switching to use AprilTag detection, the robot is able to locate itself on the map and know which way it is entering the T-intersection. A lookup then gives the legal turns available to the robot. In testing, the robot sometimes misses an AprilTag while driving at the center of the duckietown, so instead we just take the first AprilTag at an intersection it sees and let the robot infer its future position based on the turns it makes.

<h4 id="duckiebot-tailing-behaviour">Duckiebot Tailing Behaviour</h4>

<p>Implementing Duckiebot following included two main tasks:</p>

<p><b>1. Keep a safe distance from the leader.</b></p>

<p>To keep a safe distance behind the bot, we first get the distance of the back of the leader bot, to our bot. We subscribed to the topic /hostname/duckiebot_distance_node/distance and compared the published distance to our distance threshold to decide if it is too close that we should stop. We determined a safe distance of 0.50 meters to maintain between the bots, thus if a reading lower than 0.50 is received, the Duckiebot stops motion. <br></p>

<p>After the current duckiebot stops at a stop line, the robot will wait until either the leader robot goes 0.80 meters away or if the leader robot is no longer detected and then make the turn.</p>

<p><b>2. Follow the direction that leader Duckiebot is turning.</b></p>

<p>The duckiebot remembers where the dot pattern was last seen in the image and makes a turn decision based on that. This is done by a simple linear decision boundary by computing the distance between the dot pattern and a dot on the image representing the direction we can turn to. However, this does not work very well in testing due to errors in the observations. The robot can enter the intersection at a tilted angle, and it may observe the dot pattern at the right side even if the leader robot is going straight. The inconsistency of the duckiebot detection described in the Discussion section compounds this issue.</p>

<h2 id="results">Results</h2>

<div class="row justify-content-md-center">
    <video width="320" height="240" controls="">
    <source src="../../assets/vid/412_lab3/part1.mp4" type="video/mp4"></source>
        Your browser does not support the video tag.
    </video>
</div>
<div class="caption">
    Video 1. Duckiebot Driving and Tailing:
The duckiebot following the leader making two left turns, but fails at the end due to the stop line timer value set too low and it mistakes the stop line from the other side as the stop line of a new intersection.
</div>

<h2 id="qas">QAs</h2>

<p><b>How well did your implemented strategy work? Was it reliable? In what situations does it perform poorly?</b><br>
When driving by itself, the robot is able to follow the lane and turn relatively consistently. When following the leader robot, the robot is able to detect when the leader robot stops most of the time, except when the duckiebot detection node does not see the robot in front of the camera. When turning in an intersection, the robot can not find which way the leader robot turns toward, and the result is inconsistent from time to time. After visualizing the leader robot’s dot pattern position in rqt_image_view, we found that the detection loses track of the dot pattern once the leader robot starts turning. However, when the robot finds the right direction, it is able to make the turn most of the time.</p>

<h2 id="discussion">Discussion</h2>

<p>Below lists some difficulties encountered by us:</p>

<ul>
<li>We had a bug caused by updating the PID controller while the robot is not in lane following mode (i.e. stop behind a robot or turning in an intersection). The robot appears to suddenly drift after it turns and it took us a while to find the cause.</li>

<li>Occasionally the robot does not respond to wheel commands. We noticed while turning, though the code is sending messages to set opposite velocity to two wheels but the robot sometimes does not turn. We tried replicating the issue by letting it execute custom wheel commands remotely for a set period of time, and found that around one in ten times it skips the command, despite the console output showing the robot does receive the command.

<ul>
<li>We hypothesize that this could come from one of the following reasons: 1) the main thread of the lane following node is doing too much work processing images causing delay, 2) the message is either lost or gets delayed in the ROS message bus. However, we did not look into it further due to time constraints.</li>

<li>We tried two turning methods including gently turning into the target lane or going forward and turning 90 degrees to the target direction. In either case the issue persists.</li>
</ul>
</li>
<li>Inconsistent duckiebot rear dot detection: Looking at the rqt_image_view output of the duckiebot detection node, we noticed while we are able to detect them, the detection is error prone even when the leader robot is right in front of the current robot and standing still, and gets worse when the leader robot is leaning one way or when two robots are turning (with the dot pattern tilting more than around 45 degree angle to the camera, the detection always fail). When the detection does pick up the leader robot’s dot pattern, the detection flickers from time to time causing the current robot to sometimes believe the leader robot has moved.

<ul>
<li>Initially we thought either the detection rate was too low or the LED light was disrupting the detection. However the same issue still persists after we turned off the LED and increased the detection rate. We also tried cleaning the lens to increase the detection consistency and adding a timer for the robot to wait a bit before it is sure the leader robot has gone away.</li>
</ul>
</li>
<li>Determining the turn direction of the leader: relying on the position of the rear dots proved difficult due to the inconsistent detection results. Naturally when turning left the leader robot will 1) enter the intersection, 2) turn to the left side and 3) enter the target lane. While executing this sequence of actions, the path of the rear dots in our robot’s camera appears moving to the right then disappears. This is because the leader robot’s front end moves left and rear end moves right when it rotates counterclockwise, and after it makes the turn the camera can no longer pick up the dot pattern because of the viewing angle. Thus no turns or wrong turns can be made.</li>

<li>Sometimes the LED light does not respond to service requests. We tried to set its lights to flicker on turning, but two of the four lamps did not respond to set custom led pattern requests. This was not a problem in previous exercises because the LED tasks were simpler, requiring only the same color light on four lamps. We do not know what caused this issue for the lack of a way to debug the LED light.</li>
</ul>

<p>We also found that with the increased number of parameters in the program to tune, it becomes a lot more time consuming to tune them. This may be helped by setting a topic on which the program listens for parameter changes for us to tune the parameters on the fly.</p>

<h2 id="references">References</h2>

<p>dt-AprilTags repository README.md: <a href="https://github.com/duckietown/lib-dt-AprilTags" rel="external nofollow noopener" target="_blank">https://github.com/duckietown/lib-dt-AprilTags</a><br>
Duckiebot detection template repo: <a href="https://github.com/XZPshaw/CMPUT412503_exercise4" rel="external nofollow noopener" target="_blank">https://github.com/XZPshaw/CMPUT412503_exercise4</a><br>
Led_emitter_node comments from dt-core: <a href="https://github.com/duckietown/dt-core/blob/daffy/packages/led_emitter/src/led_emitter_node.py" rel="external nofollow noopener" target="_blank">https://github.com/duckietown/dt-core/blob/daffy/packages/led_emitter/src/led_emitter_node.py</a><br></p>

          </article>

        </div>

    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Leen  Alzebdeh. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script defer src="/assets/js/common.js"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
